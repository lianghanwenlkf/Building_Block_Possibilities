# Building_Block_Possibilities
## 1.目的
### 现有七块积木，探究将其拼成立方体共有几种可能性。
![c771d10824cd35edbf4b16f3f88dce6](https://github.com/user-attachments/assets/be4de232-837f-4839-8ac4-4f1f74f2444f)
![07c8e64904f4f907e2b219ce18a063c](https://github.com/user-attachments/assets/c8ce3778-cd0e-4d01-b4d7-8664295bed00)
## 2.思路
### 观察七块积木的特征，其中六块积木是由4个小正方体组成，剩余一块是由3个小正方体组成。由于各积木为不可形变的刚体，可考虑用积木小正方体的中心点来表征积木的形状和位置。建立三维直角坐标系，取x=1、2、3，y=1、2、3，z=1、2、3的组合，共27个点。按照4：4：4：4：4：4：3的比例随机划分，若与积木形状相符则保存当前组合。找出所有满足条件的组合，考虑同一种组合下不同摆放方式的可能性，去除重复组合，最后绘制所有可能性的示意图。
## 3.步骤
### 3.1 find_point：生成所有可能的点组合
#### 首先生成一个包含 27 个点的列表，然后根据积木小方块数量（3或4），使用 itertools.combinations 生成27个点选出3或4个点的所有可能的组合，需要在主函数中设置n=3或n=4。为了减小后续计算量，观察七块积木的特征，计算每个点与其他点之间的欧几里得距离，如果某个点与其他任何一个点之间的最小距离大于等于1.1，则直接排除该组合。最后把可能的情况保存到4_points_combinations.json或3_points_combinations.json文件中。
### 3.2 find_buildings：寻找符合积木的点组合
#### 定义积木1到积木7的点坐标。读取上一步保存的数据，针对每个点组合，生成该组合的所有旋转状态，包括绕x、y、z轴旋转0°、90°、180°、270°等。然后计算该组合的形心，计算对应积木的形心，平移该组合所有的点，使得两形心重合，此时检查该组合是否每个点都与对应积木的点重合，若是，则保存该组合到building_i.json中。
### 3.3 paint_1：绘制各积木所有可能的情况
#### 读取上一步中的building_i.json，绘制积木1到积木7所有可能出现的位置坐标，分别保存到1到7号文件夹中。
### 3.4 find_result：找出能拼出立方体的所有可能情况
#### 将积木1到积木7所有可能的情况进行组合，若这27个点没有重复，则说明这7块积木能够拼成立方体；若有若干点坐标是重合的，说明空间上有冲突，该组合不满足要求。计算出共有11520种情况，保存所有满足要求的积木组合至valid_sets.json中。
### 3.5 unique：排除摆放方式影响
#### 以骰子为例，骰子向上面共有6种情况，在同一个顶面的情况下，4个侧面都有可能成为正面，故立方体共有24种摆放方式。在所有可能的情况中，计算积木i所有点与积木i+1所有点的距离之和乘以特定系数作为特征值，若6个特征值均相同，则认为是同一种组合方式的不同摆放位置，存放于字典同一个key里。计算出去除重复后共有480种情况，保存至valid_sets_unique.json。
### 3.6 paint_2：绘制最终结果
#### 读取valid_sets_unique.json，绘制所有可能，并把同一种组合方式的不同摆放位置放置于同一个文件夹中。
